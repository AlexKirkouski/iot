MODULE Mite;

REQUIRE Options, Country, Organization, 
        OrgDevice, OrgMeasurement, 
        OrgController, OrgControllerDevice,
        OrgManagement, OrgManagementReport,
        ProcessMonitor, SQLUtils, ProcessUtils, Backup, Eval,
        GrafanaDashboard,
        MqttServer, Server,
        Export, 
        Telegram, Viber, Skype, Slack, Icon, Modbus;

simID 'Sim ID' = DATA STRING (Device);
EXTEND FORM deviceTypes
    PROPERTIES (d) simID
;
writeSimID(LONG l, STRING simID) + {
    APPLY FOR Device d = device(l) DO
        simID(d) <- simID;
}
deviceBySimID = GROUP AGGR Device d BY simID(d);

simID 'Sim ID' = DATA STRING (Controller);
EXTEND FORM controllerTypes
    PROPERTIES (c) simID
;

temperatureType = GROUP AGGR MeasurementType type WHERE name(type) = r'Температура';
humidityType = GROUP AGGR MeasurementType type WHERE name(type) = r'Влажность';
batteryType = GROUP AGGR MeasurementType type WHERE name(type) = r'Батарея';

isDayOff(DATE d) += isDayOff(defaultCountry(), d);
fixed(MeasurementType mt) += mt = batteryType();

maxFixedValue 'Макс. фикс. значение' (ManagementDevice md, MeasurementType mt) = GROUP MAX OVERRIDE value(right(ValuesCondition cv)) IF device(left(cv)) = md AND measurementType(left(cv)) = mt,
    value(left(cv)) IF device(right(cv)) = md AND measurementType(right(cv)) = mt;
minFixedValue 'Мин. фикс. значение' (ManagementDevice md, MeasurementType mt) = GROUP MIN OVERRIDE value(right(ValuesCondition cv)) IF device(left(cv)) = md AND measurementType(left(cv)) = mt,
    value(left(cv)) IF device(right(cv)) = md AND measurementType(right(cv)) = mt;
                                                                   
GROUP settings 'Настройки' : public;                                                   
measurementPeriod 'Период измерений' = DATA NUMERIC (Device) IN settings;
transmissionPeriod 'Период передачи' = DATA NUMERIC (Device) IN settings;
maxTemperature 'Макс. температура' (Device d) = maxFixedValue(d AS Device, temperatureType()) IN settings;
maxHumidity 'Макс. влажность' (Device d) = maxFixedValue(d AS Device, humidityType()) IN settings;
minTemperature 'Мин. температура' (Device d) = minFixedValue(d AS Device, temperatureType()) IN settings;
minHumidity 'Мин. влажность' (Device d) = minFixedValue(d AS Device, humidityType()) IN settings;
adjustmentTemperature 'Температура корр.' (Device d) = importAdjustmentValue(d AS Device, temperatureType()) IN settings;
adjustmentHumidity 'Влажность корр.' (Device d) = importAdjustmentValue(d AS Device, humidityType()) IN settings;

updateDeviceSettings 'Обновить' INTERNAL 'mite.UpdateDeviceSettingsAction' (Device) IN settings; 
WHEN CHANGED (measurementPeriod(Device d)) OR CHANGED (transmissionPeriod(d)) OR 
        CHANGED (maxTemperature(d)) OR CHANGED (maxHumidity(d)) OR
        CHANGED (adjustmentTemperature(d)) OR CHANGED (adjustmentHumidity(d)) OR
        CHANGED (minTemperature(d)) OR CHANGED (minHumidity(d)) DO
    updateDeviceSettings(d);
    
EXTEND FORM devices
    PROPERTIES (d) PANEL measurementPeriod, transmissionPeriod, minTemperature, maxTemperature, minHumidity, maxHumidity, adjustmentTemperature, adjustmentHumidity, updateDeviceSettings
;

DESIGN devices {
    settings {
        MOVE GROUP (settings, d) { horizontal = FALSE; };
    }
}

///// РАСПИСАНИЕ КОРРЕКТИРОВКИ /////

// Единый класс расписания
CLASS AdjustSchedule 'Расписание корр.';
organization 'Организация' = DATA Organization (AdjustSchedule);
name 'Название' = DATA STRING[100] (AdjustSchedule) NONULL IN id;
timeFrom 'Начало' = DATA TIME (AdjustSchedule) NONULL;
timeTo 'Окончание' = DATA TIME (AdjustSchedule) NONULL;

// Дефолтные расписания задаются целиком для организации: для рабочих и для выходных
workdayAdjustSchedule = DATA AdjustSchedule (Location);
dayOffAdjustSchedule = DATA AdjustSchedule (Location);
nameWorkdayAdjustSchedule 'Расписание (раб. дни)' (Location l) = name(workdayAdjustSchedule(l));
nameDayOffAdjustSchedule 'Расписание (вых.)' (Location l) = name(dayOffAdjustSchedule(l));

dataScheduleFor = DATA AdjustSchedule (Location, DATE);

CONSTRAINT organization(dataScheduleFor(Location l, DATE d)) != organization(l) CHECKED BY dataScheduleFor MESSAGE 'Организация расписания должна совпадать с организацией точки размещения'; 
CONSTRAINT organization(workdayAdjustSchedule(Location l)) != organization(l) CHECKED BY workdayAdjustSchedule MESSAGE 'Организация расписания должна совпадать с организацией точки размещения'; 
CONSTRAINT organization(dayOffAdjustSchedule(Location l)) != organization(l) CHECKED BY dayOffAdjustSchedule MESSAGE 'Организация расписания должна совпадать с организацией точки размещения'; 
    
// Выбор расписания на дату для организации
scheduleFor(Location l, DATE d) = 
    OVERRIDE dataScheduleFor(l, d),
        IF isDayOff(d) THEN dayOffAdjustSchedule(l) ELSE workdayAdjustSchedule(l);
nameScheduleFor 'Расписание' (Location l, DATE d) = name(scheduleFor(l, d));
dataTimeFrom = DATA TIME (Location, DATE);
dataTimeTo = DATA TIME (Location, DATE);
timeFrom 'Начало' (Location l, DATE d) = OVERRIDE dataTimeFrom(l, d), timeFrom(scheduleFor(l, d));  
timeTo 'Окончание' (Location l, DATE d) = OVERRIDE dataTimeTo(l, d), timeTo(scheduleFor(l, d));

adjustValues 'Учавствует в корректировке' = DATA BOOLEAN (Management);
overChangedNames(Management cm) += CHANGED(adjustValues(cm));
overCopyNames (Management cm, Management d) +{
    adjustValues(cm) <- adjustValues(d);
}
EXTEND FORM controllerManager
    PROPERTIES (c) adjustValues
;

maxAdjFixedValue 'Макс. фикс. значение' (ManagementDevice md, MeasurementType mt) = GROUP MAX OVERRIDE value(right(ValuesCondition cv)) IF device(left(cv)) = md AND measurementType(left(cv)) = mt AND adjustValues(controller(cv)),
    value(left(cv)) IF device(right(cv)) = md AND measurementType(right(cv)) = mt AND adjustValues(controller(cv)) MATERIALIZED;
minAdjFixedValue 'Мин. фикс. значение' (ManagementDevice md, MeasurementType mt) = GROUP MIN OVERRIDE value(right(ValuesCondition cv)) IF device(left(cv)) = md AND measurementType(left(cv)) = mt AND adjustValues(controller(cv)),
    value(left(cv)) IF device(right(cv)) = md AND measurementType(right(cv)) = mt AND adjustValues(controller(cv)) MATERIALIZED;

noise 'Отклонение значения (0..1)' = DATA DOUBLE (Organization);
periodMinutes 'Отклонение периода (мин.)' = DATA DOUBLE (Organization);
noise(Device d, MeasurementType mt) = noise(organization(d)) IF mt IS MeasurementType;
periodMinutes(Device d, MeasurementType mt) = periodMinutes(organization(d)) IF mt IS MeasurementType; // minutes
adjustConfigured 'Корр. настроена' (Device d, MeasurementType mt) =
    noise(d, mt) AND periodMinutes(d, mt) AND (maxAdjFixedValue(d, mt) OR minAdjFixedValue(d, mt));
showAdjustment(Device d, MeasurementType mt) += 1 IF adjustConfigured(d, mt);

noiseValue (Device d, MeasurementType mt) = (maxAdjFixedValue(d, mt) - minAdjFixedValue(d, mt)) * noise(d, mt) MATERIALIZED;

timeFrom(Device d, ZDATETIME zdt) = timeFrom(location(d), DATE(zdt));
timeTo(Device d, ZDATETIME zdt) = timeTo(location(d), DATE(zdt));
adjustTimeFrom(Device d, MeasurementType mt, ZDATETIME zdt) = sumMinutes(timeFrom(d, zdt), -periodMinutes(d, mt)); 
adjustTimeTo(Device d, MeasurementType mt, ZDATETIME zdt) = sumMinutes(timeTo(d,zdt), periodMinutes(d, mt)); 

adjust(Device d, MeasurementType mt, DOUBLE prevValueToTarget, INTEGER secondsToTarget) =
    IF secondsToTarget <= measurementPeriod(d) OR abs(prevValueToTarget) <= noiseValue(d, mt) THEN 0.0
        ELSE exp(ln(noiseValue(d, mt) / abs(prevValueToTarget)) / round0(secondsToTarget / measurementPeriod(d))) * prevValueToTarget;
adjustTargetValue(DOUBLE target, Device d, MeasurementType mt, INTEGER secondsToTarget) = target - adjust(d, mt, target - prevLastValue(d, mt), secondsToTarget) + (random() - 0.5) * noiseValue(d, mt);

// Вспомогательный clamp в диапазон [min, max] если границы заданы
adjustTargetValue(Device d, MeasurementType mt, ZDATETIME zdt, DOUBLE v) =
        IF TIME(zdt) >= adjustTimeFrom(d, mt, zdt) AND TIME(zdt) <= adjustTimeTo(d, mt, zdt) AND v IS DOUBLE THEN
            CASE WHEN TIME(zdt) > timeTo(location(d), DATE(zdt)) THEN adjustTargetValue(v, d, mt, subtractSeconds(TIME(zdt), adjustTimeTo(d, mt, zdt))) // we're coming back
                 WHEN v > maxAdjFixedValue(d, mt) THEN min(adjustTargetValue(maxAdjFixedValue(d, mt) - noiseValue(d, mt), d, mt, subtractSeconds(TIME(zdt), timeFrom(d, zdt))), v)
                 WHEN v < minAdjFixedValue(d, mt) THEN max(adjustTargetValue(minAdjFixedValue(d, mt) + noiseValue(d, mt), d, mt, subtractSeconds(TIME(zdt), timeFrom(d, zdt))), v) 
                 ELSE v;

// Применяем зажатие по расписанию во время финальной корректировки измерений
finalAdjustValue(Measurement m, MeasurementType mt, DOUBLE v) += adjustTargetValue(device(m), mt, dateTime(m), v);

// UI (точка размещения): все настройки расписания переносим в форму точек размещения
// - дефолтные расписания для организации (выводим селекторы, организация берётся из organization(l))
// - локальное переопределение на конкретную дату (редактируемое свойство dataScheduleFor)
// - справочник расписаний AdjustSchedule (NEW/DELETE)
EXTEND FORM locations
    OBJECTS ds = DATE
    FILTERS iterate(ds, currentDate(), sum(currentDate(), 60)) OR dataScheduleFor(l, ds)     
    PROPERTIES VALUE(ds), nameScheduleFor(l, ds), timeFrom(l, ds), timeTo(l, ds), noise(o), periodMinutes(o) 

    PROPERTIES (l) nameWorkdayAdjustSchedule, nameDayOffAdjustSchedule

    OBJECTS as = AdjustSchedule
    FILTERS organization(as) = o
    PROPERTIES (as) name, timeFrom, timeTo, NEW, DELETE
;

DESIGN locations {
    tab {
        NEW adjustPanel {
            caption = 'Параметры корректировки';
            NEW orgRow {
                horizontal = TRUE;
                caption = 'По умолчанию для организации';
                MOVE PROPERTY(noise(o));
                MOVE PROPERTY(periodMinutes(o));
            }
            MOVE BOX (as) { fill = 1; }
        }
    }
    BOX(l) {
        NEW tabll {
            fill = 1;
            tabbed = TRUE;
            NEW dateRow {
                caption = 'Расписания корректировки';
                MOVE BOX(ds);
            }
            NEW templates {
                caption = 'Шаблоны управления';
                MOVE BOX(tm);
            }
        }
    }
}

///// КОРРЕКТИРОВКА ЗАДНИМ ЧИСЛОМ /////

isAdjustActive 'Корр. активна' (Device d, MeasurementType mt) =
    adjustConfigured(d, mt) AND
            TIME(currentZDateTime()) >= adjustTimeFrom(d, mt, currentZDateTime()) AND
            TIME(currentZDateTime()) <= adjustTimeTo(d, mt, currentZDateTime());

retroDateFrom 'Период с' = DATA LOCAL ZDATETIME ();
retroDateTo 'Период по' = DATA LOCAL ZDATETIME ();
retroDataMaxValue 'Макс. (корр.)' = DATA LOCAL DOUBLE (MeasurementType);
retroDataMinValue 'Мин. (корр.)' = DATA LOCAL DOUBLE (MeasurementType);
retroMaxValue 'Макс. (корр.)' (Device d, MeasurementType mt) = OVERRIDE retroDataMaxValue(mt), maxAdjFixedValue(d, mt);
retroMinValue 'Мин. (корр.)' (Device d, MeasurementType mt) = OVERRIDE retroDataMinValue(mt), minAdjFixedValue(d, mt);

applyRetroAdjust 'Применить корректировку' (Device d) {
    ASK 'Применить корректировку задним числом для датчика ' + id(d) + '?' DO {
        value(Measurement m, MeasurementType mt) <-
                IF value(m, mt) > retroMaxValue(d, mt)
                    THEN retroMaxValue(d, mt) - (OVERRIDE noiseValue(d, mt), 0.0) * random()
                    ELSE retroMinValue(d, mt) + (OVERRIDE noiseValue(d, mt), 0.0) * random()
            WHERE device(m) = d AND dateTime(m) >= retroDateFrom() AND dateTime(m) <= retroDateTo() AND
                  number(type(d), mt) AND
                  ((retroMaxValue(d, mt) AND value(m, mt) > retroMaxValue(d, mt)) OR
                   (retroMinValue(d, mt) AND value(m, mt) < retroMinValue(d, mt)));
    }
}

EXTEND FORM devices
    OBJECTS rcmt = MeasurementType
    FILTERS number(type(d), rcmt)
    PROPERTIES (rcmt) READONLY name
    PROPERTIES (d, rcmt) READONLY isAdjustActive, maxAdjFixedValue, minAdjFixedValue
    PROPERTIES (d, rcmt) retroMaxValue, retroMinValue
    PROPERTIES retroDateFrom(), retroDateTo()
    PROPERTIES (d) PANEL applyRetroAdjust
;

DESIGN devices {
    tab {
        NEW adjustment {
            caption = 'Корректировка';
            horizontal = FALSE;
            fill = 1;
            NEW retroPeriodBox {
                caption = 'Период корректировки задним числом';
                horizontal = TRUE;
                MOVE PROPERTY(retroDateFrom());
                MOVE PROPERTY(retroDateTo());
                MOVE PROPERTY(applyRetroAdjust(d));
            }
            MOVE BOX(rcmt) {
                fill = 1;
            }
        }
    }
}

GROUP root;
GROUP result : root;

GROUP json;

//code = DATA LOCAL STRING(INTEGER);
date = DATA LOCAL DATETIME (INTEGER);
imei = DATA LOCAL STRING(INTEGER);
value = DATA LOCAL STRING(INTEGER);

countImei = GROUP SUM 1 BY imei(INTEGER row);

FORM importResults
    OBJECTS items = INTEGER IN result

//    PROPERTIES(items) code
    PROPERTIES(items) IN json date, value, imei
    FILTERS imported(items);
    
GROUP nav 'Параметры импорта БТС';
navLogin 'Логин доступа' = DATA STRING () IN nav;
navPassword 'Пароль доступа' = DATA STRING () IN nav;
lastImportTime 'Последнее время импорта' = DATA DATETIME () IN nav;

importMeasurements 'Импортировать измерения' () {
    LOCAL token = STRING (); 

    EXTERNAL HTTP 'https://api.nav.by/info/integration_get_token.php?type=GET_TOKEN&login=$1&password=$2' PARAMS navLogin(), navPassword() TO exportFile;
    IF failedHttp() THEN {
        MESSAGE 'Unable to get token ' + statusHttp() + '\n' + STRING(JSONFILE(exportFile())) NOWAIT;
        RETURN;
    }
    
    IMPORT JSON FROM exportFile() TO () token;
    
    EXTERNAL HTTP 'https://api.nav.by/info/integration.php?type=EVENTS&token=$1&event_codes=temp_sensor1&datetime=$2&limit=ALL' PARAMS token(), (OVERRIDE lastImportTime(),1982_01_01_12:00) TO exportFile;

    IF failedHttp() THEN {
        MESSAGE 'Unable to get data ' + statusHttp() + '\n' + STRING(JSONFILE(exportFile())) NOWAIT;
        RETURN;
    }
    
    IMPORT importResults JSON FROM exportFile();
    
    LOCAL missingImeis = STRING ();
    missingImeis() <- GROUP CONCAT STRING imei IF countImei(imei) AND NOT deviceBySimID(imei), ', ' ORDER imei;
    IF missingImeis() THEN {
        MESSAGE 'IMEIs not found : ' + missingImeis() NOWAIT;        
        RETURN;
    }
    
    FOR Device dv = deviceBySimID(imei(INTEGER row)) AND NOT disableImport(dv) DO {
        NEW m = Measurement { 
            dateTime(m) <- ZDATETIME(date(row)); 
            device(m) <- dv; 
            idImport(m) <- LONG(imei(row)); 
            unAdjustedValue(m, temperatureType()) <- DOUBLE(value(row)); 
        }
    }
    lastImportTime() <- currentDateTime();
    APPLY;
}

GROUP ftp 'Параметры импорта FTP';
importFTPPath 'Путь к файлу импорта' = DATA STRING () IN ftp;
importExtraFTPPath 'Путь к файлу импорта (доп.)' = DATA STRING () IN ftp;

importFTPMeasurements (STRING path) {
    LOCAL token = STRING (); 

    READ path TO exportFile;
//    IF failedHttp() THEN {
//        MESSAGE 'Unable to get token ' + statusHttp() + '\n' + STRING(JSONFILE(exportFile())) NOWAIT;
//        RETURN;
//    }
    
    LOCAL NESTED eui64 = STRING (INTEGER);
    LOCAL NESTED tmmeasure = LONG (INTEGER);
    LOCAL NESTED temperatur = DOUBLE (INTEGER);
    LOCAL NESTED humidity = DOUBLE (INTEGER);
    LOCAL NESTED battery = DOUBLE (INTEGER);
    IMPORT DBF FROM exportFile() TO eui64, tmmeasure, temperatur, humidity, battery 
    
    LOCAL missingEui64 = STRING ();
    missingEui64() <- GROUP CONCAT STRING eui64 IF [GROUP SUM 1 IF eui64(INTEGER row) = eui64]() AND NOT deviceBySimID(eui64), ', ' ORDER eui64;
    IF missingEui64() THEN {
        MESSAGE 'EUI64s not found : ' + missingEui64() NOWAIT;        
        RETURN;
    }
    
    FOR [GROUP SUM 1 IF Device dv = deviceBySimID(eui64(INTEGER row)) AND ZDATETIME tz = toZDateTime(tmmeasure(row)) AND (tz > dateTime(lastMeasurement(dv)) OR NOT lastMeasurement(dv)) BY dv](Device dv) AND NOT disableImport(dv) DO {
        APPLY FOR dv = deviceBySimID(eui64(INTEGER row)) AND ZDATETIME tz = toZDateTime(tmmeasure(row)) AND (tz > dateTime(lastMeasurement(dv)) OR NOT lastMeasurement(dv)) INLINE NEW m = Measurement DO {
            dateTime(m) <- tz;
            device(m) <- dv;
            //            idImport(m) <- LONG(eui64(row)); 
            unAdjustedValue(m, temperatureType()) <- DOUBLE(temperatur(row));
            unAdjustedValue(m, humidityType()) <- DOUBLE(humidity(row));
            unAdjustedValue(m, batteryType()) <- DOUBLE(battery(row));
        }
        IF canceled() THEN
            BREAK;
    }
    IF NOT canceled() THEN 
        delete(path);
}
importFTPMeasurements 'Импортировать измерения' () {
    IF importFTPPath() THEN 
       importFTPMeasurements(importFTPPath());
}
importExtraFTPMeasurements 'Импортировать измерения (доп.)' () {
    IF importExtraFTPPath() THEN
        importFTPMeasurements(importExtraFTPPath());
}

EXTEND FORM options
    PROPERTIES () navLogin, navPassword, lastImportTime, importMeasurements, importFTPPath, importExtraFTPPath, importFTPMeasurements, importExtraFTPMeasurements 
;
DESIGN options {
    pane {
        NEW hnav {
            caption = 'Параметры импорта БТС'; 
            MOVE PROPERTY(navLogin());
            MOVE PROPERTY(navPassword());
            MOVE PROPERTY(lastImportTime());
            MOVE PROPERTY(importMeasurements());
        }
        NEW hftp {
            caption = 'Параметры импорта FTP'; 
            MOVE PROPERTY(importFTPPath());
            MOVE PROPERTY(importExtraFTPPath());
            MOVE PROPERTY(importFTPMeasurements());
            MOVE PROPERTY(importExtraFTPMeasurements());            
        }
    }
}

excludeFromPrintMeasurements 'Искл. из отчета изм. (NEW)' = DATA BOOLEAN (Device);
 
FORM printMeasurements
    OBJECTS dFrom = ZDATETIME PANEL, dTo = ZDATETIME PANEL, o = Organization PANEL
    PROPERTIES name(o)
    OBJECTS d = Device
    FILTERS organization(d) = o, NOT excludeFromPrintMeasurements(d) 
    OBJECTS m = Measurement SUBREPORT
    FILTERS dateTime(m) >= dFrom AND dateTime(m) <= dTo
    FILTERS device(m) = d
    PROPERTIES deviceId(m), dateTime(m), nameDeviceType(m), temp = value(m, temperatureType()), hum = value(m, humidityType())
;

emailMeasurements 'Отправить измерения (NEW)' (Organization o, ZDATETIME dFrom, ZDATETIME dTo) {
    PRINT printMeasurements OBJECTS o = o, dFrom = dFrom, dTo = dTo PDF TO exportFile;
    EMAIL 
            SUBJECT ('Отчет об измерениях: ' + DATETIME(dFrom) + ' - ' + DATETIME(dTo)) 
            TO email(o)
            BODY 'Добрый день, <br/><br/>Отчет по датчикам: ' + (GROUP CONCAT '' + id(Device d) IF organization(d) = o AND NOT excludeFromPrintMeasurements(d), ';<br/>' ORDER d) + '<br/>' + ' в приложении. <br/><br/><br/>С уважением, <br/>Команда MITE' 
            ATTACH exportFile() NAME 'ДоминантаФарм_' + DATE(DATETIME(dFrom)) + (IF DATE(DATETIME(dTo)) != DATE(DATETIME(dFrom)) THEN '-' + DATE(DATETIME(dTo)) ELSE ''); 
}

printMeasurements 'Распечатать измерения (NEW)' (Organization o) {
    DIALOG dialogZDateTimes OBJECTS dFrom = subtractSeconds(currentZDateTime(), 60*60) INPUT, dTo INPUT DO
        PRINT printMeasurements OBJECTS o = o, dFrom = dFrom, dTo = dTo;
}

emailMeasurements 'Отправить измерения (NEW)' (Organization o) {
    DIALOG dialogZDateTimes OBJECTS dFrom = subtractSeconds(currentZDateTime(), 60*60) INPUT, dTo INPUT DO
        emailMeasurements(o, dFrom, dTo);
}

EXTEND FORM devices
    PROPERTIES excludeFromPrintMeasurements(d)
;

EXTEND FORM organizations
    PROPERTIES (o) printMeasurements TOOLBAR, emailMeasurements TOOLBAR
;

getpackage(FILE file) {
    printToLog('GETPACKAGE : ' + extension(file) + ' -> ' + STRING(RAWFILE(file)));
} @@noauth;

lagrangePoints = DATA LOCAL NESTED DOUBLE (DOUBLE);
lagrangeResult = DATA LOCAL NESTED DOUBLE ();
calcLagrange INTERNAL 'mite.LagrangeAction' (DOUBLE, INTEGER);

run() {
    LOCAL points = DOUBLE (TIME);
    // points(04:00) <- 1; 
    points(07:30) <- 22;
    points(08:30) <- 8;
    points(10:00) <- 4;
    points(17:15) <- 7.9;
    // points(19:00) <- 4; 

    lagrangePoints(DOUBLE x) <- GROUP MAX points(TIME t) IF DOUBLE(toSeconds(t)) = x;

    FOR value(Measurement m, MeasurementType mt) AND deviceId(m) = 1210000026 AND name(mt) = r'Температура'
        AND dateTime(m, mt) > ZDATETIME(2022_04_25_00:00) AND dateTime(m, mt) < ZDATETIME(2022_04_25_23:35)
        DO {

        calcLagrange(DOUBLE(toSeconds(TIME(dateTime(m, mt)))), 1);

        ASK 'Change \n DATE:' + dateTime(m, mt) + '\n OLD VALUE:' + value(m, mt) + '\n NEW VALUE' + lagrangeResult() DO {
            APPLY value(m, mt) <- lagrangeResult();
        } ELSE
        BREAK ;
    }
}
